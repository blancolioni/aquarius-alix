@!aquarius:actionscript
@before Compilation_Unit do
@Top.Package_Name := Top.Qualified_Name;
@Set_Output (Ada_Body_Name (Top.Package_Name));
--  Generated by Aquarius/Tropos; do not edit

with Ada.Containers.Doubly_Linked_Lists;
with Ada.Directories;
with Tropos.Reader;

package body [Top.Package_Name] is
   
   pragma Style_Checks (Off);   
   
@for Pkg of Top.Config_Package_List loop
   function Get_[Top.Config_Package_Map.Element (Pkg).Name] is
     new Tropos.Get_Enum ([Top.Config_Package_Map.Element (Pkg).Image]);
@end loop;

@for T of Top.File_List loop
   package [T]_Lists is
     new Ada.Containers.Doubly_Linked_Lists ([Top.File_Map.Element (T)/Named_Type.Type_Name]);
   [T]_List : [T]_Lists.List;
@end loop;

   -----------------
   -- Read_Config --
   -----------------
   
   procedure Read_Config
     (Config_Path : String)
   is
@      for T of Top.File_List loop
      procedure Read_[T];
@      end loop;

@      for T of Top.File_List loop
      procedure Read_[T] is
         Full_Config : constant Tropos.Configuration :=
           Tropos.Reader.Read_Config
             (Ada.Directories.Compose
               (Config_Path, "[Top.File_Map.Element (T).File_Name]"));
      begin
         for Config of Full_Config loop
            declare
               New_Item : [Top.File_Map.Element (T)/Named_Type.Type_Name];
            begin
               New_Item.Config := Config;
               [T]_List.Append (New_Item);
            end;
         end loop;
      end Read_[T];      
      
@      end loop;
   begin
@      for T of Top.File_List loop
      Read_[T];
@      end loop;
   end Read_Config;
@for all loop
@   case Tree is
@      when Type_Declaration =>
@         if Tree/header then

   function [Tree/header/identifier] (Item : [Tree/identifier]) return [Tree/header/named_type.Type_Name] is
   begin
@            if Tree/header/named_type.Type_Name = "String" then
      return Item.Config.Config_Name;
@            else 
      return [Tree/header/named_type.Type_Name]'Value (Item.Config.Config_Name);
@            end if;
   end [Tree/header/identifier];
@         end if;
@      when Type_Definition =>
@         if Tree/Record_Type then
@            null;
@         elsif Tree/Named_Type then
   
   function Value (Item : [Tree.Type_Name]) return [Tree/Named_Type.Type_Name] is
   begin
      return Item.Config.Value;
   end Value;
@         end if;
@      when Record_Field =>

@         if Tree/record_component_type/named_type then
   function [Tree.Ada_Name] (Item : [Tree^Type_Declaration.Type_Name]) return [Tree.Tree_Type.Return_Type_Name] is
   begin
@     if Tree/record_component_type/named_type.Standard_Type then
@        if Tree.Default_Value then
      return Item.Config.Get ("[Tree.Config_Name]", [Tree.Default_Value]);
@        else
      return Item.Config.Get ("[Tree.Config_Name]");
@        end if;
@     elsif Top.Config_Package_List.Contains (Tree/record_component_type/named_type.Type_Name) then
      return Get_[Top.Config_Package_Map.Element (Tree/record_component_type/named_type.Type_Name).Name]
               (Item.Config, "[Tree.Config_Name]");
@     elsif Top.Types.Contains (Tree/record_component_type/named_type.Type_Name) then
      return [Tree/record_component_type/named_type.Type_Name]'(Config => Item.Config.Child ("[Tree.Config_Name]"));
@     end if;
   end [Tree.Ada_Name];
@         else
   function Num_[Tree.Ada_Name] (Item : [Tree^Type_Declaration.Type_Name]) return Natural is
   begin
      return Item.Config.Child ("[Tree.Config_Name]").Child_Count;
   end Num_[Tree.Ada_Name];
   
   function [Tree.Ada_Name] 
     (Item  : [Tree^Type_Declaration.Type_Name];
      Index : Positive)
     return [Tree.Tree_Type.Return_Type_Name] is
   begin
      return Item.Config.Child ("[Tree.Config_Name]").Get (Index);
   end [Tree.Ada_Name];
@         end if;
@      when File_Declaration =>

   procedure Scan_[Tree/identifier]
     (Process : not null access
        procedure (Item : [Tree/named_type.Type_Name]'Class))
   is
   begin
      for Item of [Tree/identifier]_List loop
         Process (Item);
      end loop;
   end Scan_[Tree/identifier];
@   end case;
@end loop;

end [Top.Package_Name];
