top_level ::= compilation_unit
case_sensitive = false

identifier         ::= standard ada_identifier
numeric_literal    ::= standard ada_numeric_literal
character_literal  ::= standard ada_character_literal
string_literal     ::= standard ada_string_literal
delimiter          ::= delimiters "&()+,;|"
symbol             ::= standard ada_symbol
comment            ::= standard ada_comment

format list_of_declarations indented_child
format record_components indented_child

format ';' no_space_before no_space_after new_line_after
format '.' no_space_before no_space_after
format '(' space_before no_space_after
format ')' no_space_before space_after
format ',' no_space_before space_after
format ''' no_space_before no_space_after

compilation_unit ::= top_level_interface_declaration | top_level_package_declaration | top_level_procedure_declaration

top_level_package_declaration ::= 'package' qualified_identifier 'is' list_of_declarations 'end' matching_qualified_identifier ';'

top_level_procedure_declaration ::= 'procedure' qualified_identifier [ formal_arguments ] 'is' list_of_declarations 'begin' sequence_of_statements 'end' matching_qualified_identifier ';' 

sequence_of_statements ::= < statement ';' >

statement ::= null_statement | assignment_statement | call_statement | declare_statement
            | invoke_statement
            
null_statement ::= 'null'

declare_statement ::= 'declare' list_of_declarations 'begin' sequence_of_statements 'end'

call_statement ::= object_reference

assignment_statement ::= object_reference ':=' expression

invoke_statement ::= 'invoke' cap_and_endpoint [ invocation_arguments ]

cap_and_endpoint ::= identifier [ '/' numeric_literal ]

invocation_arguments ::= 'with' < invocation_argument / ',' >

invocation_argument ::= identifier '=>' expression

expression ::=
    relation { boolean_operator relation }

relation ::=
        simple_expression [ relational_operator simple_expression  ]

simple_expression ::=
    [ unary_adding_operator ] term { binary_adding_operator term }

term ::= factor { multiplying_operator factor }

factor ::= primary
       | unary_primary_operator primary

boolean_operator ::=
        'and' | 'and' 'then' | 'or' | 'or' 'else' | 'xor'

relational_operator ::= '=' | '/=' | '<' | '<=' | '>' | '>='

binary_adding_operator ::= '+' | '-' | '&'

unary_adding_operator ::= '+' | '-'

unary_primary_operator ::= 'abs' | 'not'

multiplying_operator ::= '*' | '/' | 'mod' | 'rem'

primary ::= numeric_literal
          | character_literal 
          | string_literal 
          | interface_reference 
          | object_reference
          | aggregate
          | sub_expression
          
sub_expression ::= '(' expression ')'

aggregate ::= '(' aggregate_item ',' aggregate_item_list ')'

aggregate_item ::= expression

aggregate_item_list ::= < aggregate_item / ',' >

interface_reference ::= 'interface' qualified_identifier

object_reference ::= identifier { object_qualifier }

object_qualifier ::= '.' object_reference
                   | ''' attribute
                   | '(' actual_argument_list ')'

attribute ::= identifier

actual_argument_list ::= < expression / ',' >

top_level_interface_declaration ::=
   'interface' qualified_identifier optional_constraint [ ':' parent_interfaces ] [ optional_aspect_list ] 'is'
      list_of_declarations
   'end' matching_qualified_identifier ';'

optional_constraint ::= [ '(' identifier ':' typeref ')' ]

optional_aspect_list ::= [ 'with' aspect_list ]

aspect_list ::= < aspect / ',' >

aspect ::= aspect_name [ '=>' static_expression ]

aspect_name ::= identifier [ ''' identifier ]

static_expression ::= expression

parent_interfaces ::= < qualified_identifier / ',' >

qualified_identifier ::= < identifier / '.' >

matching_qualified_identifier ::= qualified_identifier

list_of_declarations ::= { declaration ';' }

declaration ::= subprogram_declaration | type_declaration | object_declaration

object_declaration ::= identifier ':' [ 'constant' ] [ typeref ] [ ':=' expression ]

subprogram_declaration ::= function_declaration | procedure_declaration

function_declaration ::= 'function' identifier [ formal_arguments ] 'return' typeref optional_aspect_list

procedure_declaration ::= 'procedure' identifier [ formal_arguments ] optional_aspect_list

type_declaration ::= 'type' identifier 'is' type_definition optional_aspect_list

type_definition ::= record_type_definition
                  | new_type_definition
                  
new_type_definition ::= 'new' qualified_identifier

record_type_definition ::=
   'record' record_components 'end' 'record'

record_components ::= < record_component ';' >

record_component ::= identifier ':' typeref

formal_arguments ::= '(' < formal_argument / ';' > ')'

formal_argument ::= identifier ':' [ argument_spec ] typeref

argument_spec ::= 'in' | inout | 'out'

inout ::= 'in' 'out'

typeref ::= interface_typeref
          | named_typeref

interface_typeref ::= 'interface' qualified_identifier
named_typeref ::= qualified_identifier
