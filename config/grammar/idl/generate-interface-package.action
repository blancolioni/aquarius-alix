@!aquarius:actionscript
@declare Package_Name : constant String := 
@   /Top_Level_Interface_Declaration/Qualified_Identifier.Image;
@declare Interface_Name : constant String :=
@   /Top_Level_Interface_Declaration/Qualified_Identifier.Last.Image;
@Set_Output (Ada_Specification_Name (Package_Name));
@for Context of Top.Contexts loop
with [Context];
@end loop;

package [Package_Name] is

   pragma Style_Checks (Off);
   
   type Root_[Interface_Name]_Interface is
      limited interface
@if /Top_Level_Interface_Declaration/Parent_Interfaces then
@for /Top_Level_Interface_Declaration/Parent_Interfaces loop
      and [.Image]
@end loop;
@end if;
      and Root_Rose_Interface;
      
@for /Top_Level_Interface_Declaration/List_Of_Declarations loop
@   case Tree is
@      when Constant_Declaration =>
   [/Identifier] : constant [(if /Typeref then /Typeref else "")]:= [/Expression];
@      when Type_Declaration =>
   type [/Identifier.Image] is
@         case /Type_Definition is
@            when Record_Type_Definition =>
      record
@               for record_component of /Record_Components loop
         [/Identifier] : [/Typeref.Ada_Name];
@               end loop;
      end record;
@            when New_Type_Definition =>
                new [Qualified_Identifier.Image];
@         end case;
@      when Subprogram_Declaration =>

   not overriding
   [(if /Function_Declaration then "function" else "procedure")] [/Identifier]
     (Item : in out Root_[Interface_Name]_Interface
@ if /Formal_Arguments then
@ for Formal_Argument of /Formal_Arguments loop
     ; [/Identifier] : [.Mode] [/Typeref.Ada_Name]
@ end loop;
@ end if;
     )
@ if /Function_Declaration then
     return [/Typeref.Ada_Name]
@ end if;
   is abstract;
@   end case;
@end loop;

   type [Interface_Name]_Interface is
     access all Root_[Interface_Name]_Interface'Class;
     
end [Package_Name];
