declare Next_Send_Word : Natural := 0;
declare Next_Recv_Word : Natural := 0;
declare Next_Send_Cap  : Natural := 0;
declare Next_Recv_Cap  : Natural := 0;
declare Current_Declaration : Tree := null;

Top.Qualified_Name :=
   /Top_Level_Interface_Declaration/Qualified_Identifier.Image;
Top.Package_Name := Qualified_Name & ".Client";
Top.Base_Name :=
   /Top_Level_Interface_Declaration/Qualified_Identifier.Last.Image;
Top.Interface_Name := Base_Name & "_Interface";
Top.Client_Record_Name := Base_Name & "_Client_Interface";
Top.Interface_Class_Name := "Root_" & Interface_Name;
Top.Contexts := Create_Set;
Top.Bases := Create_Map;
Top.Subprograms := Create_Map;

for all loop
   case Tree is
      when Parent_Interfaces =>
         for Tree loop
            Top.Contexts.Include (.Image);
            Top.Bases.Insert (.Image, Load (Top.Containing_Directory & "/" & To_File_Name (.Image, "idl")));
         end loop;
      when Typeref =>
         if /Interface_Typeref then
            .Ada_Name := Qualified_Identifier.Image & "_Interface";
            Top.Contexts.Include (Qualified_Identifier.Image);
         elsif /Address_Typeref then
            .Ada_Name := "System.Address";
            Top.Contexts.Include ("System");
         elsif /Word_Typeref then
            .Ada_Name := "Rose.Words.Word";
            Top.Contexts.Include ("Rose.Words");
         elsif /Storage_Typeref then
            .Ada_Name := "System.Storage_Elements.Storage_Count";
            Top.Contexts.Include ("System.Storage_Elements");
         else
            .Ada_Name := /Qualified_Identifier.Image;
            if /Qualified_Identifier.Length = 1 then
               Top.Contexts.Include (/Qualified_Identifier.Image);
            else
               Top.Contexts.Include (Concat (/Qualified_Identifier, 1, /Qualified_Identifier.Length - 2));
            end if;
         end if;
      when Declaration =>
         Current_Declaration := Tree;
         .Send_Words := 0;
         .Recv_Words := 0;
      when Subprogram_Declaration =>
         Next_Send_Word := 0;
         Next_Recv_Word := 0;
         Next_Send_Cap := 0;
         Next_Recv_Cap := 0;
         Top.Subprograms.Insert (/Identifier.Image, Tree);
      when Formal_Argument =>
         if /Argument_Spec then
            if /Argument_Spec.Image = "out" then
               Next_Recv_Word := Next_Recv_Word + 1;
               .Recv_Word := Next_Recv_Word;
               .Send_Word := 0;
               .Mode := "out";
            elsif /Argument_Spec.Image = "in" then
               Next_Send_Word := Next_Send_Word + 1;
               .Send_Word := Next_Send_Word;
               .Recv_Word := 0;
               .Mode := "in";
            elsif /Argument_Spec.Image = "inout" then
               Next_Send_Word := Next_Send_Word + 1;
               .Send_Word := Next_Send_Word;
               Next_Recv_Word := Next_Recv_Word + 1;
               .Recv_Word := Next_Recv_Word;
               .Mode := "in out";
            end if;
         else
            Next_Send_Word := Next_Send_Word + 1;
            .Send_Word := Next_Send_Word;
            .Recv_Word := 0;
            .Mode := "in";
         end if;
         Current_Declaration.Send_Words := Next_Send_Word;
         Current_Declaration.Recv_Words := Next_Recv_Word;
   end case;
end loop;
