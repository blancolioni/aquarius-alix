before class_declaration do
end;

after class_declaration do
end;

after class_declaration/class_header do
   parent.class := class_header.class;
   top.class := tree.class;
   parent.class.clients := (list => new Array, table => new Map);
   parent.class.inheritance := (list => new Array, table => new Map, full_list => new Array);
   parent.class.features := (list => new Array, table => new Map);
end;

before class_declaration/inheritance do
   child.inheritance := parent.class.inheritance;
end;

before class_declaration/features do
   child.features := parent.class.features;
end;

before class_header do
   tree.class := (deferred => 0, expanded => 0, frozen => 0, generic => 0);
end;

after class_header/header_mark do
   if child.image = "deferred" then
      parent.class.deferred := 1;
   elsif child.image = "expanded" then
      parent.class.expanded := 1;
   elsif child.image = "frozen" then
      parent.class.frozen := 1;
   end if;
end;

after class_header/class_name do
   parent.class.name := class_name.image.to_lower;
end;

after class_header/formal_generics do
   parent.class.generic := 1;
   parent.class.generic_parameters := formal_generics;
end;

after class_declaration/class_header do
   parent.class := class_header.class;
end;

before inheritance do
end;

after inherit_list/inherited do
   parent^inheritance.inheritance.list.append (child.inherit);
   parent^inheritance.inheritance.table.set (child.inherit.name, child.inherit);
end;

after inherited/class_type do
   parent.inherit := (name => class_type.name)
end;

before inherited/feature_adaptation do
   child.inherit := parent.inherit
end

before feature_adaptation/redefine do
   parent.inherit.redefines := (list => new Array, table => new Map)
   child.redefines := parent.inherit.redefines
end

before redefine/feature_list do
   child.features := parent.redefines
end

after redefine/feature_list do
end

after feature_list/feature_name do
   parent.features.list.append (feature_name.image.to_lower)
   parent.features.table.set (feature_name.image.to_lower, 1)
end

before features do
end;

before feature_declaration do
   tree.new_feature_names := new Array;
   tree.feature_body := new Map;
end;

after feature_declaration/declaration_body do
   tree.feature_body.type := child.type
   tree.feature_body.deferred := child.deferred
   tree.feature_body.redefine := top.class.inheritance.redefines
   tree.feature_body.value := child.value

   if child.type then
      if child.type.class_name then
         tree.client_info := (name => child.type.class_name);
         if not parent^class_declaration.class.clients.table.get (tree.client_info.name) then
            parent^class_declaration.class.clients.list.append (tree.client_info);
            parent^class_declaration.class.clients.table.set (tree.client_info.name, tree.client_info);
         end if;
      end if;
   end if;
   if child.value then
      tree.feature_body.routine := 1
      tree.feature_body.local := child.value.local
   else
      tree.feature_body.attribute := 1
   end if
   if child.formal_arguments then
      tree.feature_body.formal_arguments := child.formal_arguments
   else
      tree.feature_body.formal_arguments := (list => new Array, table => new Map)
   end if
end;

after feature_declaration do
   for name in tree.new_feature_names loop
      tree.new_feature := tree.feature_body.clone;
      tree.new_feature.name := name
      tree.new_feature.standard_name := name.to_lower
      tree^features.features.list.append (tree.new_feature);
      tree^features.features.table.set (tree.new_feature.standard_name, tree.new_feature);
   end loop;
   tree.feature_body.names := tree.new_feature_names
   tree.feature_body.canonical_name := tree.feature_body.names.first
end;

after declaration_body/formal_arguments do
   tree.formal_arguments := child.arguments;
end;

after declaration_body/type_mark do
   parent.type := child.type;
end;

after declaration_body/feature_value do
   tree.value := child.value;
   tree.deferred := child.deferred
end;

after feature_value/explicit_value do
   parent.value := (constant_feature => child)
end

after feature_value/routine do
   parent.value := (routine => child, local => (list => new Array, table => new Map))
   parent.deferred := child.deferred
end

before routine do
   tree.feature := tree^feature_declaration.feature_body
end

after routine/feature_body do
   parent.deferred := child.deferred
end

after feature_body/deferred do
   parent.deferred := 1
end

after new_feature_list/new_feature do
   parent^feature_declaration.new_feature_names.append (child.name);
end;

after new_feature/extended_feature_name do
   parent.name := child.name;
end;

after extended_feature_name/feature_name do
   parent.name := feature_name.image;
end;

after type_mark/type do
   parent.type := child.type;
end;

before type do
   type.type := new Map;
end;

after type/class_type do
   parent.type.class_name := class_type.name;
end;

after class_type/class_name do
   parent.name := class_name.image.to_lower;
end;