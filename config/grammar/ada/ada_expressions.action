function Conforms (type_1, type_2) is
begin
   if type_1.name = type_2.name then
      return 1;
   elsif type_1.universal then
      if type_1.type.type_class = type_2.type.type_class then
	     return 1;
      else
	     return 0;
      end if;
   elsif type_2.universal then
      if type_1.type.type_class = type_2.type.type_class then
	     return 1;
      else
	     return 0;
      end if;
   else
      return 0;
   end if;
end Conforms;

function Find_Object (Table, name) is
begin
   if Table.get (name) then
      return Table.get (name);
   elsif Table.parent then
      return find_Object (Table.parent, name);
   else
      return (error => "undefined: " & name);
   end if;
end Find_Object;

function Type_Error (tree, expected, found) is
begin
   if expected.length = 0 then
      tree.error ("no expected types");
   elsif expected.length = 1 then
      if found /= 0 then
	     tree.error ("expected " & expected.get (1).name & " but found " & found.name);
      else
	     tree.error ("expected " & expected.get (1).name);
	  end if;
   elsif found then
      tree.error ("no interpretation of " & tree.concatenated_image & " matches type " & found.name);
   else
      tree.error ("type error");
   end if;
end Type_Error;

function Check_Expected_Types(tree, expected, found) is
   OK := 0;
begin   
   if expected /= 0 then
      tree.found_types := [];
      for possible in expected loop
	     OK := Conforms (found, possible);
	     if OK then
		    tree.found_types.append (possible)
		 end if;
	  end loop;

	  if tree.found_types.length = 0 then
	     Type_Error (tree, expected, found);
	  end if;
   end if;
end Check_Expected_Types;

before expression/relation 
    or relation/simple_expression
	or simple_expression/term
	or term/factor
	or factor/primary
do
   child.expected_type := parent.expected_type;
end;

after primary/object_reference do
   parent.inferred_type := child.object.type;
end;

after primary/numeric_literal do
   if parent.expected_type then
      Check_Expected_Types(primary, primary.expected_type, top.universal_integer);
   end if;
end;

before primary/aggregate do
   child.target := parent.expected_type.get (1);
   child.expected_type := parent.expected_type;
end;

before aggregate do
   if tree.target.type.type_class = "array" then
      tree.remaining_type := tree.target.type.component_type;
   elsif tree.target.type.type_class = "record" then
      tree.agg_types := new Array;
      for component in tree.target.type.components loop
	     tree.agg_types.append (component);
	  end loop;
	  tree.next_component := 0;
   else
      tree.error ("invalid type for aggregate: " & tree.target.image)
   end if;
end;

before aggregate/selector do
   child.target := parent.target;
   child.agg_types := parent.agg_types;
end;

before aggregate/selector_expression do
   child.target := parent.target;
   child.agg_types := parent.agg_types;
end;

before selector_expression/selector do
   child.target := parent.target;
   child.agg_types := parent.agg_types;
end;

before selector_expression/expression do
   parent.aggregate := parent^aggregate;
   if parent.aggregate.agg_types then
      parent.aggregate.next_component := parent.aggregate.next_component + 1;
	  child.expected_type := [parent.agg_types.get (parent.aggregate.next_component).type];
   end if;
end;

before selector/list_of_selector_items do
   child.target := parent.target;
   child.agg_types := parent.agg_types;
end;

before list_of_selector_items/selector_item do
   child.target := parent.target;
   child.agg_types := parent.agg_types;
end;

before selector_item/constant_expression do
   parent.saved_symbol_table := top.current_symbol_table;
   top.current_symbol_table := parent.target.type.component_table;
end;

after selector_item/constant_expression do
   top.current_symbol_table := parent.saved_symbol_table;
end;

after object_reference/direct_name do
   parent.object := find_object (top.current_symbol_table, direct_name/identifier.text);
   if parent.object.error then
      direct_name.error (parent.object.error)
	  parent.object := null;
   elsif parent.expected_type then
      Check_Expected_Types(direct_name, parent.expected_type, parent.object.type);
   end if;
end;
